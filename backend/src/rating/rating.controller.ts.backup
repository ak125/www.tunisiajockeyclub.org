import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Logger,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { RatingCalculatorService } from './rating-calculator.service';
import { PrismaService } from '../prisma/prisma.service';

@Controller('api/ratings')
export class RatingController {
  private readonly logger = new Logger(RatingController.name);

  constructor(
    private ratingCalculator: RatingCalculatorService,
    private prisma: PrismaService,
  ) {}

  @Get('horse/:horseId')
  async getHorseRating(@Param('horseId') horseId: string) {
    try {
      const horse = await this.prisma.horse.findUnique({
        where: { id: horseId },
      });

      if (!horse) {
        throw new HttpException('Cheval non trouvé', HttpStatus.NOT_FOUND);
      }

      const currentRating = Number(horse.currentRating) || 0;
      
      return {
        horseId,
        horseName: horse.name,
        currentRating,
        lastUpdated: new Date(),
        message: 'Rating récupéré avec succès',
      };

    } catch (error: any) {
      this.logger.error(`Erreur: ${error.message}`);
      throw new HttpException(
        error.message || 'Erreur lors de la récupération du rating',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  @Post('calculate-initial/:horseId')
  async calculateInitialRating(@Param('horseId') horseId: string) {
    try {
      const horse = await this.prisma.horse.findUnique({
        where: { id: horseId },
        include: {
          raceResults: {
            orderBy: { createdAt: 'desc' },
            take: 3,
          },
        },
      });

      if (!horse) {
        throw new HttpException('Cheval non trouvé', HttpStatus.NOT_FOUND);
      }

      if (horse.raceResults.length < 3) {
        throw new HttpException(
          `Le cheval doit avoir au moins 3 courses. Actuellement: ${horse.raceResults.length}`,
          HttpStatus.BAD_REQUEST,
        );
      }

      const initialRating = await this.ratingCalculator.calculateInitialRating(horseId);

      return {
        horseId,
        horseName: horse.name,
        initialRating,
        message: 'Rating initial calculé avec succès',
      };

    } catch (error: any) {
      this.logger.error(`Erreur: ${error.message}`);
      throw new HttpException(
        error.message || 'Erreur lors du calcul du rating initial',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  @Post('calculate-race')
  async calculateRaceRatings(@Body() request: { raceId: string }) {
    try {
      const race = await this.prisma.race.findUnique({
        where: { id: request.raceId },
        include: {
          raceResults: {
            include: { horse: true },
          },
        },
      });

      if (!race) {
        throw new HttpException('Course non trouvée', HttpStatus.NOT_FOUND);
      }

      if (!race.raceResults.length) {
        throw new HttpException('Aucun résultat trouvé pour cette course', HttpStatus.NOT_FOUND);
      }

      const raceRatings = await this.ratingCalculator.calculateRaceRatings(request.raceId);

      return {
        raceId: race.id,
        raceName: race.name,
        ratingsCalculated: raceRatings.length,
        performanceRatings: raceRatings,
        message: 'Ratings calculés avec succès',
      };

    } catch (error: any) {
      this.logger.error(`Erreur: ${error.message}`);
      throw new HttpException(
        error.message || 'Erreur lors du calcul des ratings de course',
        error.status || HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  @Get('statistics')
  async getRatingStatistics() {
    try {
      return await this.ratingCalculator.getRatingStatistics();
    } catch (error: any) {
      this.logger.error(`Erreur: ${error.message}`);
      throw new HttpException(
        'Erreur lors de la récupération des statistiques',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}
